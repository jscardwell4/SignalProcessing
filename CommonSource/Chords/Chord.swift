//
//  Chord.swift
//  Chord Finder
//
//  Created by Jason Cardwell on 7/31/17.
//  Copyright (c) 2017 Moondeer Studios. All rights reserved.
//
import Foundation
import Accelerate
import MoonKit

/// A structure for representing a chord in Western music. A `Chord` is composed of a root
/// chroma value, representing the root interval of the chord, and an interval pattern from
/// which the remaining chroma values can be derived. The raw value for a chord is generated by
/// taking the raw value for the interval pattern and using the 8 unused most significant bits to
/// encode the root chroma's raw value.
public struct Chord: RawRepresentable {

  /// A name or label describing the chord.
  public var name: String { return "\(root)\(pattern.suffix)" }

  /// The chord's root chroma value.
  public let root: Chroma

  /// The chord's pattern describing the intervals used in the chord's construction.
  public let pattern: ChordPattern

  /// The raw value for the chord which is a composite of the raw values of `root` and `pattern`.
  public var rawValue: UInt32 { return pattern.rawValue | UInt32(root.rawValue) << 24 }

  /// The chroma template composed of the weighted chromas corresponding to `pattern`.
  public var template: ChromaTemplate { return ChromaTemplate(chord: self) }

  /// The chromas corresponding to the pattern intervals.
  public let chromas: [Chroma]

  /// Derives the chord's pitches given the tone height for the root chroma.
  ///
  /// - Parameter rootToneHeight: The tone height for the root chroma.
  /// - Returns: The chord's pitches given `rootToneHeight`.
  public func pitches(rootToneHeight: Int) -> [Pitch] {

    let rootPitch = Pitch(chroma: root, toneHeight: rootToneHeight)
    let rawRoot = rootPitch.rawValue


    var pitches = [rootPitch]

    for interval in pattern.intervals {
      pitches.append(Pitch(rawValue: rawRoot + interval.semitones))
    }

    return pitches

  }

  /// The chromas that must be present to be considered the chord.
  public var criticalChromas: [Chroma] {

    // Create a mutable copy of `chromas`.
    var chromas = self.chromas

    // Get the index for the fifth or return all the chromas.
    guard let fifth = self[.P5], let index = chromas.firstIndex(of: fifth) else { return chromas }

    // Remove the fifth.
    chromas.remove(at: index)

    // Return the remaining chromas.
    return chromas

  }

  /// Initializing with a root for a chord and its pattern. Generates a chroma template using
  /// the specified chord pattern and root.
  ///
  /// - Parameters:
  ///   - root: The chroma value for the chord's root.
  ///   - pattern: The chord pattern.
  public init(root: Chroma, pattern: ChordPattern) {

    self.root = root
    self.pattern = pattern

    chromas = [root] + pattern.intervals.map({root[$0]})
    
  }

  /// Initializing with a raw value.
  ///
  /// - Parameter rawValue: The raw value from which to deduce the chord's `root` and `pattern`.
  public init(rawValue: UInt32) {
    self.init(root: Chroma(rawValue: Int(rawValue >> 24)), pattern: ChordPattern(rawValue: rawValue))
  }

  /// Initializing with a root for the chord and a list of intervals. Creates a `ChordPattern`
  /// with the specified intervals and invokes `init(name:pattern:)`.
  ///
  /// - Parameters:
  ///   - root: The chroma value of the chord's root.
  ///   - intervals: The intervals, other than the implied `1`, composing the chord.
  public init(root: Chroma, _ intervals: ChordInterval...) {
    self.init(root: root, pattern: ChordPattern(intervals))
  }

  /// Provides the chord interval for a member of `chromas` or `nil` if the specified chroma
  /// is not part of the chord.
  ///
  /// - Parameter chroma: The chroma whose interval is desired.
  /// - Returns: The interval of `chroma` or `nil` if `chroma` ∉ `chromas`.
  public subscript(chroma: Chroma) -> ChordInterval? {

    // Get the index of `chroma` in `chromas` or return `nil`.
    guard let index = chromas.firstIndex(of: chroma) else { return nil }

    // Return the corresponding interval.
    return index == 0 ? .P1 : pattern.intervals[index - 1]

  }

  /// Accessor for the chroma at the specified interval. Returns `nil` if the chord does not
  /// include `interval`.
  ///
  /// - Parameter interval: The interval for which the chroma shall be returned.
  public subscript(interval: ChordInterval) -> Chroma? {

    // Check whether the interval is the root.
    guard interval != .P1 else { return root }

    // Check whether the chord pattern contains `interval`.
    guard pattern.contains(interval: interval) else { return nil }

    // Return the chroma at `interval` from `root`.
    return root[interval]

  }

  /// A chroma vector with zeros for chroma's not present and ones for present chromas.
  public var chromaRepresentation: ChromaVector {
    let vector = ChromaVector()
    for chroma in Set(chromas) {
      vector[chroma] = 1
    }
    return vector
  }

}

extension Chord: Hashable {

  public  static func ==(lhs: Chord, rhs: Chord) -> Bool {
    return lhs.root == rhs.root && lhs.pattern == rhs.pattern
  }

  public var hashValue: Int { return rawValue.hashValue }

}

extension Chord: CustomStringConvertible {

  public var description: String { return name }

}

extension Chord: ExpressibleByStringLiteral {

  /// Initializing with a string value. If the root chroma and pattern cannot be deduced
  /// than the chord will be intialized to 'CM'.
  ///
  /// - Parameter value: The string describing the chord.
  public init(stringLiteral value: String) {

    // Capture the root chroma and the suffix or initialize with a default of 'CM'.
    guard let match = (~/"([a-gA-G][♭b]?)(.+)").firstMatch(in: value),
          let chromaLiteral = match.captures[1]?.substring,
          let suffix = match.captures[2]?.substring
      else
    {
      self.init(root: .C, pattern: .﹡M)
      return
    }

    let root = Chroma(stringLiteral: String(chromaLiteral))
    let pattern = ChordPattern(stringLiteral: String(suffix))

    self.init(root: root, pattern: pattern)

  }

}

extension Chord: CustomReflectable {

  public var customMirror: Mirror {
    return Mirror(self, children: ["name": name, "root": root, "pattern": pattern])
  }

}
